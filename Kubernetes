1. what is kubernates?
Kubernetes or k8s for short, it is a open source platform that manages containzered application hence also called as container orcheration tool and it automates the deployment, scaling, and management of containerized applications, making it easier to manage complex applications across a cluster of machines.

2. Define architecture of kubernetes?
Kubernetes architecture is designed around master-slave model, that is control plane which manage and oversees the entire cluster it includes 
components like API server, etcd, scheduler, control manager and it has worker node or node it includes components like kubelet, kube proxy, CRI.
CONTROL PLANE:
    1.API Server
      - It is the main management point of the cluster and is also called as brain of the cluster.
      - All the components are directly connected to the API server, they communicate through the API server only and no other component will 
        communicate directly with each other.
      - This is the only component that connects and got access to etcd.
      - All the cluster requests are authenticated and authorized by the API server.
      - The API server has a watch mechanism for watching the changes in the cluster.
           
    2.ETCD
      - ectd is a distributed, key-value store used for storing the complete cluster information/data. 
      - ectd contains data such as configuration management of cluster,distributed work and basically complete cluster information.
           
    3.Sheduler
      - The scheduler always watches for a new pod request and decides which worker node this pod should be created.
    
    4.Controller Manager
      - Monitors the state of various resources in the cluster and takes corrective action if the current state deviates from the desired state.
      - it has some inbuild controllers such as Deployment, DaemonSet, ReplicaSet, Replication controller,node controller, jobs, cronjob, 
          endpoint controller, namespace controller, etc.   
    	
    5.Cloud controller manager
    	- These controllers help us to connect with the public cloud provider service and this component is maintained by cloud providers only.
    	
WORKER NODE: 	
    1.Kubelet
      - It is an agent that runs on each and every worker node and it always watches the APIserver for pod-related changes running in its  
          worker node.
      - kubelet always makes sure that the assigned pods to its worker nodes are running.
      - kubelet is the one that communicates with the containerization tool (docker daemon) through docker API (CRI).     
      - work of kubelet is to create and run the pods. Always report the status of the worker node and each pod to the API server.
            
    2.Service proxy 
      - Service proxy runs on each and every worker node and is responsible for watching the API server for any changes in service configuration 
        (any network-related configuration).    
      - Based on the configuration service proxy manages the entire network of worker nodes.
      - Network proxy that is used to route traffic between pods. The Kubernetes Proxy is responsible for ensuring that traffic from one pod 
        reaches the correct pod.
        
    3.Conatainer runtime interface
     	- The software responsible for running containers, such as Docker or containerd.
	
3. What happens when a new pod request comes to the control plane / Master node ?
    1.  kubectl writes to the API Server.
    2.  API Server validates the request and persists it to etcd.
    3.  etcd notifies back the API Server.
    4.  API Server invokes the Scheduler.
    5.  Scheduler decides where to run the pod on and return that to the API Server.
    6.  API Server persists it to etcd.
    7.  etcd notifies back the API Server.
    8.  API Server invokes the Kubelet in the corresponding node.
    9.  Kubelet talks to the Docker daemon using the API over the Docker socket to create the container.
    10. Kubelet updates the pod status to the API Server.
    11. API Server persists the new state in etcd.

4. YAML fields?
   apiVersion: v1
        - This is the version of API used to create a k8s object.
        - The fields are case-sensitive and YAML uses camelcase.
        - The type of APIs are alpha, beta, and stable.
          
   kind: Pod
        - here we specify which object we need to create. 
        - Always object name's first letter is capital.
          
   metadata:
        - This field is used to provide information on the object which we are creating.
        - Information such as name, labels, and annotations.     
      
   spec:
        - This is used to do the actual configuration of the object.

5. Deployment controller / Deployment / Deployment k8s
       - Deployment is used to create replicas of similar kind of pods and It makes sure that at a given point of time that number of replicas of 
         pods is always running by using ReplicaSet 
         controller.
       - If we update the configuration of deployment, it will automatically updates in all the pod replicas.
       - Rollout and Rollback of pod update is possible. 
       - We can use different deployment strategy for update,  by default it uses RollingUpdate.
       - we can pause the deployment whenever we need.
       - Deployment internally got its own autoscaler which is of type horizontal smaller (hap).

EXAMPLE:
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ip-app-deployment
          spec:
            replicas: 4
            selector:
              matchLabels:
                app: ip-app
            template:
              metadata:
                labels:
                  app: ip-app
              spec:
                containers:
                - name: ipapp
                  image: harshajain/ip-app:1
                  ports:
                  - containerPort: 80

6. Labels, selectors, and annotations
    Labels (Identifiable metadata):

       - We can provide labels to any object in K8S
       - We can have the same label on multiple objects/resources in K8S.   
       - The label key must consist of alphanumeric characters, dashes (-), or periods (.), and it must not start or end with a dash or period.
       - Labels are commonly used for organizing and categorizing resources. They help in grouping related resources for querying, filtering, and organizing purposes.  

    Selectors:
      - Selectors are used to select, filter and identify the labeled objects.
         Types of selectors
          1. equality-based
              In this selector, we can use only one operator which is equal_to (=, ==) or (!=) not_equal
              It looks for an exact match for the label 
                                            app = nginx  or app: nginx
        
                                            app != nginx        
         2. set-based 
            Set-based selectors allow selecting resources based on multiple values for a label key.
            It uses set operators such as in, notin, exists, and doesnotexist to perform the selection.
                                      matchExpressions:
                                         - key: environment
                                           operator: In
                                           values:
                                              - development
                                              - testing

   Annotations:
          - These are non-identifying metadata so we can't use Selectors on annotations. 
          - This for record purpose only, like we can provide some user information to objects.
       EXAMPLE:
                 ex: personal_info, phone_number, imageregistry, author     
                        metadata:
                            annotations:
                                 author: harsha

7. ReplicaSet vs Replication controller
    - Both ensure that at a given point in time, the specified number of replicas are always running.
    - The replication controller is a very old controller now it is replaced by ReplicaSet.
    - The only difference between them is Replication controller supports only equality-based selectors but 
    - ReplicaSet support both set-based and equality-based selector.

8. DaemonSet 
   - DaemonSet creates exactly one pod on each and every worker node in the cluster and ensures that all that are always running.
   - If a new worker node is added or deleted, DaemonSet will also add or delete the pod from the respective worker node.

9. Namespace
   - Namespace in Kubernetes is a logical grouping of resources. It is used to organize resources and to control access to those resources.
   - Namespaces also allow you to control access to resources. You can create permissions that allow only certain users or groups to access resources in a particular namespace. 
   - This can be useful for security purposes, or for preventing users from accidentally deleting or modifying important resources.
   - Each and every object in k8s must be in a namespace.
   - If we won't specify a namespace, objects will be created in the default namespace of k8s.
   - namespaces are cluster level.
   - Namespaces are only hidden from each other but not fully isolated because one service in a namespace can talk to another service in another namespace using the full name 
     (service/<service_name>) followed by the namespace name

 Type of default NS
    1. default
       - This NS is used for all the objects which do not belong to any other namespace.
       - If we won't specify any namespace while creating an object in k8s then that object will be created in the default namespace.
            
    2. kube-system 
       - This namespace is always used for objects created by the k8s system.
       
    3. kube-public 
       - The objects in this namespace are available or accessible to all.
       - All the objects in this namespace are made public.

    4. kube-node-lease 
       - This namespace holds lease objects associated with each node.
       - Node lease allows the kubelet to send heartbeats so that the control plane can detect node failure.


 10. Stateful Applications vs stateless Applications
    - These applications contains User session data is saved on the server side.
    - if the server goes down, it is difficult to transfer the session data to another server. 
    - This type of application will not work, if we want to implement autoscaling.
    - Stateful applications are suitable for scenarios where data persistence and strong consistency are vital, such as databases, financial 
      applications, Auth Gateways, and ERP systems.

   stateless
    - user session data is never saved on the server side.
    - using a common authentication gateway/client token method to validate the users once for multiple microservices. 

11. Monolithic and Microservice architecture
     Monolithic architecture
        - A monolithic application has a single code base with multiple modules in it.
        - It is a single build for the entire application.
        - To make minor changes to an application, we need to rebuild and re-deploy the complete application.
        - scaling is very challenging.

    Microservice architecture 
        - A microservice application is composed of small (micro) services. 
        - Each service will have a different code base.
        - Applications are divided into as small as possible sub-applications called services which are independent of each other and are called 
          loosely coupled.    
        - Each service can be managed separately and it is deployable separately.
        - Services need not to share the same technology stack or frameworks.

12. Service (svc) (Basic network configurations in k8s)
    - Service is a REST API object with which we can define policies to access a set of pods.
    - Services are cluster-level objects.
    - By default, services are load balancers.
    - It has a Preferred port range for services is between 30000 - 32767.  

   Types of Services
    ClusterIP
        - This is the default type of service in k8S.
        - Accessible within the cluster. Dependent applications can interact with other applications internally using the ClusterIP service.
    
    NodePort
        - This service is the most primitive way to establish the external traffic directed to our applications 
          running inside the cluster in pods.
        - Automatically a ClusterIP will also be created internally.
                                                            
                                      NodePort = ClusterIP + a port mapping to all the nodes ip's.         
     
        - If we won't specify any port while creating NodePort, k8s will Automatically assign a random port between 30000 - 32767
    
    LoadBalancer
        - To exposes the Service externally we need to use an external load balancer. Kubernetes does not directly offer a load-balancing 
          component, So To exposes the Service externally you need to integrate your Kubernetes cluster with a cloud provider.
        - This service type creates load balancers in various Cloud providers like AWS, GCP, Azure, etc., to expose our application to the 
          Internet and The Cloud provider will provide a mechanism for routing the traffic to the services.

   Headless
	- has no loadbalancer in it and provides ip address for all pod  














kkk
















